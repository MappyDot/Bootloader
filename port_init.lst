   1               	 .file "port_init.c"
   2               	__SP_H__ =0x3e
   3               	__SP_L__ =0x3d
   4               	__SREG__ =0x3f
   5               	__tmp_reg__ =0
   6               	__zero_reg__ =1
   7               	 .text
   8               	.Ltext0:
   9               	 .cfi_sections .debug_frame
  10               	 .section .text.I2C_0_initialization,"ax",@progbits
  11               	.global I2C_0_initialization
  13               	I2C_0_initialization:
  14               	.LFB105:
  15               	 .file 1 "port_init.c"
   1:port_init.c   **** /**
   2:port_init.c   ****  * \file
   3:port_init.c   ****  *
   4:port_init.c   ****  * \brief Driver initialization.
   5:port_init.c   ****  *
   6:port_init.c   ****  *
   7:port_init.c   ****  * Copyright (C) 2016 Atmel Corporation. All rights reserved.
   8:port_init.c   ****  *
   9:port_init.c   ****  * \asf_license_start
  10:port_init.c   ****  *
  11:port_init.c   ****  * \page License
  12:port_init.c   ****  *
  13:port_init.c   ****  * Redistribution and use in source and binary forms, with or without
  14:port_init.c   ****  * modification, are permitted provided that the following conditions are met:
  15:port_init.c   ****  *
  16:port_init.c   ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:port_init.c   ****  *    this list of conditions and the following disclaimer.
  18:port_init.c   ****  *
  19:port_init.c   ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:port_init.c   ****  *    this list of conditions and the following disclaimer in the documentation
  21:port_init.c   ****  *    and/or other materials provided with the distribution.
  22:port_init.c   ****  *
  23:port_init.c   ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:port_init.c   ****  *    from this software without specific prior written permission.
  25:port_init.c   ****  *
  26:port_init.c   ****  * 4. This software may only be redistributed and used in connection with an
  27:port_init.c   ****  *    Atmel microcontroller product.
  28:port_init.c   ****  *
  29:port_init.c   ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:port_init.c   ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:port_init.c   ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:port_init.c   ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:port_init.c   ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:port_init.c   ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:port_init.c   ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:port_init.c   ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:port_init.c   ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:port_init.c   ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:port_init.c   ****  * POSSIBILITY OF SUCH DAMAGE.
  40:port_init.c   ****  *
  41:port_init.c   ****  * \asf_license_stop
  42:port_init.c   ****  *
  43:port_init.c   ****  *
  44:port_init.c   ****  */
  45:port_init.c   **** 
  46:port_init.c   **** /*
  47:port_init.c   ****  * Code generated by START.
  48:port_init.c   ****  *
  49:port_init.c   ****  * This file will be overwritten when reconfiguring your START project.
  50:port_init.c   ****  * Please copy examples or other code you want to keep to a separate file
  51:port_init.c   ****  * to avoid losing it when reconfiguring.
  52:port_init.c   ****  */
  53:port_init.c   **** 
  54:port_init.c   **** #include "port_init.h"
  55:port_init.c   **** 
  56:port_init.c   **** /* configure pins and initialize registers */
  57:port_init.c   **** void I2C_0_initialization(void)
  58:port_init.c   **** {
  16               	 .loc 1 58 0
  17               	 .cfi_startproc
  18               	 
  19               	 
  20               	 
  21               	.L__stack_usage =0
  22               	.LVL0:
  23               	.LBB26:
  24               	.LBB27:
  25               	.LBB28:
  26               	 .file 2 "port.h"
   1:port.h        **** 
   2:port.h        **** 
   3:port.h        **** /**
   4:port.h        ****  * \file
   5:port.h        ****  *
   6:port.h        ****  * \brief Port
   7:port.h        ****  *
   8:port.h        ****  *
   9:port.h        ****  * Copyright (C) 2016 Atmel Corporation. All rights reserved.
  10:port.h        ****  *
  11:port.h        ****  * \asf_license_start
  12:port.h        ****  *
  13:port.h        ****  * \page License
  14:port.h        ****  *
  15:port.h        ****  * Redistribution and use in source and binary forms, with or without
  16:port.h        ****  * modification, are permitted provided that the following conditions are met:
  17:port.h        ****  *
  18:port.h        ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:port.h        ****  *    this list of conditions and the following disclaimer.
  20:port.h        ****  *
  21:port.h        ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:port.h        ****  *    this list of conditions and the following disclaimer in the documentation
  23:port.h        ****  *    and/or other materials provided with the distribution.
  24:port.h        ****  *
  25:port.h        ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:port.h        ****  *    from this software without specific prior written permission.
  27:port.h        ****  *
  28:port.h        ****  * 4. This software may only be redistributed and used in connection with an
  29:port.h        ****  *    Atmel microcontroller product.
  30:port.h        ****  *
  31:port.h        ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:port.h        ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:port.h        ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:port.h        ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:port.h        ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:port.h        ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:port.h        ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:port.h        ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:port.h        ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:port.h        ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:port.h        ****  * POSSIBILITY OF SUCH DAMAGE.
  42:port.h        ****  *
  43:port.h        ****  * \asf_license_stop
  44:port.h        ****  *
  45:port.h        ****  *
  46:port.h        ****  */
  47:port.h        **** 
  48:port.h        **** #ifndef _PORT_INCLUDED_
  49:port.h        **** #define _PORT_INCLUDED_
  50:port.h        **** 
  51:port.h        **** #ifdef __cplusplus
  52:port.h        **** extern "C" {
  53:port.h        **** #endif
  54:port.h        **** 
  55:port.h        **** #include <stdint.h>
  56:port.h        **** #include <stdbool.h>
  57:port.h        **** #include <avr/io.h>
  58:port.h        **** 
  59:port.h        **** enum port_pull_mode {
  60:port.h        **** 	PORT_PULL_OFF,
  61:port.h        **** 	PORT_PULL_UP,
  62:port.h        **** };
  63:port.h        **** 
  64:port.h        **** enum port_dir {
  65:port.h        **** 	PORT_DIR_IN,
  66:port.h        **** 	PORT_DIR_OUT,
  67:port.h        **** 	PORT_DIR_OFF,
  68:port.h        **** };
  69:port.h        **** 
  70:port.h        **** /**
  71:port.h        ****  * \brief Set PORTB pin pull mode
  72:port.h        ****  *
  73:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
  74:port.h        ****  * modes are defined by device used
  75:port.h        ****  *
  76:port.h        ****  * \param[in] pin       The pin number in PORTB
  77:port.h        ****  * \param[in] pull_mode Pin pull mode
  78:port.h        ****  */
  79:port.h        **** static inline void PORTB_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
  80:port.h        **** {
  81:port.h        **** 
  82:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
  83:port.h        **** 
  84:port.h        **** 		DDRB &= ~(1 << pin);
  85:port.h        **** 
  86:port.h        **** 		PORTB |= 1 << pin;
  87:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
  88:port.h        **** 
  89:port.h        **** 		PORTB &= ~(1 << pin);
  90:port.h        **** 	}
  91:port.h        **** }
  92:port.h        **** 
  93:port.h        **** /**
  94:port.h        ****  * \brief Set PORTB data direction
  95:port.h        ****  *
  96:port.h        ****  * Select if the port pins selected by mask data direction is input, output
  97:port.h        ****  * or disabled.
  98:port.h        ****  *
  99:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 100:port.h        ****  *                      corresponding pin
 101:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 102:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 103:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 104:port.h        ****  *                      (low power state)
 105:port.h        ****  */
 106:port.h        **** static inline void PORTB_set_port_dir(const uint8_t mask, const enum port_dir direction)
 107:port.h        **** {
 108:port.h        **** 	switch (direction) {
 109:port.h        **** 	case PORT_DIR_IN:
 110:port.h        **** 		DDRB &= ~mask;
 111:port.h        **** 		break;
 112:port.h        **** 	case PORT_DIR_OUT:
 113:port.h        **** 		DDRB |= mask;
 114:port.h        **** 		break;
 115:port.h        **** 	case PORT_DIR_OFF:
 116:port.h        **** 		DDRB &= ~mask;
 117:port.h        **** 
 118:port.h        **** 		PORTB |= mask;
 119:port.h        **** 		break;
 120:port.h        **** 	default:
 121:port.h        **** 		break;
 122:port.h        **** 	}
 123:port.h        **** }
 124:port.h        **** 
 125:port.h        **** /**
 126:port.h        ****  * \brief Set PORTB single pin data direction
 127:port.h        ****  *
 128:port.h        ****  * Select if the pin data direction is input, output or disabled.
 129:port.h        ****  * If disabled state is not possible, this function throws an assert.
 130:port.h        ****  *
 131:port.h        ****  * \param[in] pin       The pin number within PORTB (0..7)
 132:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 133:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 134:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 135:port.h        ****  *                      (low power state)
 136:port.h        ****  */
 137:port.h        **** static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 138:port.h        **** {
 139:port.h        **** 	switch (direction) {
 140:port.h        **** 	case PORT_DIR_IN:
 141:port.h        **** 		DDRB &= ~(1 << pin);
 142:port.h        **** 		break;
 143:port.h        **** 	case PORT_DIR_OUT:
 144:port.h        **** 		DDRB |= 1 << pin;
 145:port.h        **** 		break;
 146:port.h        **** 	case PORT_DIR_OFF:
 147:port.h        **** 		DDRB |= ~(1 << pin);
 148:port.h        **** 
 149:port.h        **** 		PORTB |= 1 << pin;
 150:port.h        **** 		break;
 151:port.h        **** 	default:
 152:port.h        **** 		break;
 153:port.h        **** 	}
 154:port.h        **** }
 155:port.h        **** 
 156:port.h        **** /**
 157:port.h        ****  * \brief Set PORTB level
 158:port.h        ****  *
 159:port.h        ****  * Sets output level on the pins defined by the bit mask
 160:port.h        ****  *
 161:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 162:port.h        ****  *                  pin
 163:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 164:port.h        ****  *                  false = Pin levels set to "low" state
 165:port.h        ****  */
 166:port.h        **** static inline void PORTB_set_port_level(const uint8_t mask, const bool level)
 167:port.h        **** {
 168:port.h        **** 	if (level) {
 169:port.h        **** 		PORTB |= mask;
 170:port.h        **** 	} else {
 171:port.h        **** 		PORTB &= ~mask;
 172:port.h        **** 	}
 173:port.h        **** }
 174:port.h        **** 
 175:port.h        **** /**
 176:port.h        ****  * \brief Set PORTB level
 177:port.h        ****  *
 178:port.h        ****  * Sets output level on a pin
 179:port.h        ****  *
 180:port.h        ****  * \param[in] pin       The pin number for device
 181:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 182:port.h        ****  *                  false = Pin level set to "low" state
 183:port.h        ****  */
 184:port.h        **** static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
 185:port.h        **** {
 186:port.h        **** 	if (level) {
 187:port.h        **** 		PORTB |= 1 << pin;
 188:port.h        **** 	} else {
 189:port.h        **** 		PORTB &= ~(1 << pin);
 190:port.h        **** 	}
 191:port.h        **** }
 192:port.h        **** 
 193:port.h        **** /**
 194:port.h        ****  * \brief Toggle out level on pins
 195:port.h        ****  *
 196:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 197:port.h        ****  *
 198:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 199:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 200:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 201:port.h        ****  *                  pin
 202:port.h        ****  */
 203:port.h        **** static inline void PORTB_toggle_port_level(const uint8_t mask)
 204:port.h        **** {
 205:port.h        **** 	PINB = mask;
 206:port.h        **** }
 207:port.h        **** 
 208:port.h        **** /**
 209:port.h        ****  * \brief Toggle output level on pin
 210:port.h        ****  *
 211:port.h        ****  * Toggle the pin levels on pin
 212:port.h        ****  *
 213:port.h        ****  * \param[in] pin       The pin number for device
 214:port.h        ****  */
 215:port.h        **** static inline void PORTB_toggle_pin_level(const uint8_t pin)
 216:port.h        **** {
 217:port.h        **** 	PINB = 1 << pin;
 218:port.h        **** }
 219:port.h        **** 
 220:port.h        **** /**
 221:port.h        ****  * \brief Get input level on pins
 222:port.h        ****  *
 223:port.h        ****  * Read the input level on pins connected to a port
 224:port.h        ****  *
 225:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 226:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 227:port.h        ****  */
 228:port.h        **** static inline uint8_t PORTB_get_port_level(volatile uint8_t *port)
 229:port.h        **** {
 230:port.h        **** 	return PINB;
 231:port.h        **** }
 232:port.h        **** 
 233:port.h        **** /**
 234:port.h        ****  * \brief Get level on pin
 235:port.h        ****  *
 236:port.h        ****  * Reads the level on a pin connected to a port
 237:port.h        ****  *
 238:port.h        ****  * \param[in] pin       The pin number for device
 239:port.h        ****  */
 240:port.h        **** static inline bool PORTB_get_pin_level(const uint8_t pin)
 241:port.h        **** {
 242:port.h        **** 	return PINB & (1 << pin);
 243:port.h        **** }
 244:port.h        **** 
 245:port.h        **** /**
 246:port.h        ****  * \brief Write value to PORTB
 247:port.h        ****  *
 248:port.h        ****  * Write directly to the entire port register.
 249:port.h        ****  *
 250:port.h        ****  * \param[in] value   Value to write
 251:port.h        ****  */
 252:port.h        **** static inline void PORTB_write_port(const uint8_t value)
 253:port.h        **** {
 254:port.h        **** 	PORTB = value;
 255:port.h        **** }
 256:port.h        **** 
 257:port.h        **** /**
 258:port.h        ****  * \brief Set PORTC pin pull mode
 259:port.h        ****  *
 260:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 261:port.h        ****  * modes are defined by device used
 262:port.h        ****  *
 263:port.h        ****  * \param[in] pin       The pin number in PORTC
 264:port.h        ****  * \param[in] pull_mode Pin pull mode
 265:port.h        ****  */
 266:port.h        **** static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 267:port.h        **** {
 268:port.h        **** 
 269:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 270:port.h        **** 
 271:port.h        **** 		DDRC &= ~(1 << pin);
 272:port.h        **** 
 273:port.h        **** 		PORTC |= 1 << pin;
 274:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 275:port.h        **** 
 276:port.h        **** 		PORTC &= ~(1 << pin);
 277:port.h        **** 	}
 278:port.h        **** }
 279:port.h        **** 
 280:port.h        **** /**
 281:port.h        ****  * \brief Set PORTC data direction
 282:port.h        ****  *
 283:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 284:port.h        ****  * or disabled.
 285:port.h        ****  *
 286:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 287:port.h        ****  *                      corresponding pin
 288:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 289:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 290:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 291:port.h        ****  *                      (low power state)
 292:port.h        ****  */
 293:port.h        **** static inline void PORTC_set_port_dir(const uint8_t mask, const enum port_dir direction)
 294:port.h        **** {
 295:port.h        **** 	switch (direction) {
 296:port.h        **** 	case PORT_DIR_IN:
 297:port.h        **** 		DDRC &= ~mask;
 298:port.h        **** 		break;
 299:port.h        **** 	case PORT_DIR_OUT:
 300:port.h        **** 		DDRC |= mask;
 301:port.h        **** 		break;
 302:port.h        **** 	case PORT_DIR_OFF:
 303:port.h        **** 		DDRC &= ~mask;
 304:port.h        **** 
 305:port.h        **** 		PORTC |= mask;
 306:port.h        **** 		break;
 307:port.h        **** 	default:
 308:port.h        **** 		break;
 309:port.h        **** 	}
 310:port.h        **** }
 311:port.h        **** 
 312:port.h        **** /**
 313:port.h        ****  * \brief Set PORTC single pin data direction
 314:port.h        ****  *
 315:port.h        ****  * Select if the pin data direction is input, output or disabled.
 316:port.h        ****  * If disabled state is not possible, this function throws an assert.
 317:port.h        ****  *
 318:port.h        ****  * \param[in] pin       The pin number within PORTC (0..7)
 319:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 320:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 321:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 322:port.h        ****  *                      (low power state)
 323:port.h        ****  */
 324:port.h        **** static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 325:port.h        **** {
 326:port.h        **** 	switch (direction) {
 327:port.h        **** 	case PORT_DIR_IN:
 328:port.h        **** 		DDRC &= ~(1 << pin);
 329:port.h        **** 		break;
 330:port.h        **** 	case PORT_DIR_OUT:
 331:port.h        **** 		DDRC |= 1 << pin;
  27               	 .loc 2 331 0
  28 0000 3D9A      	 sbi 0x7,5
  29               	.LVL1:
  30               	.LBE28:
  31               	.LBE27:
  32               	.LBE26:
  33               	.LBB29:
  34               	.LBB30:
  35               	.LBB31:
 332:port.h        **** 		break;
 333:port.h        **** 	case PORT_DIR_OFF:
 334:port.h        **** 		DDRC |= ~(1 << pin);
 335:port.h        **** 
 336:port.h        **** 		PORTC |= 1 << pin;
 337:port.h        **** 		break;
 338:port.h        **** 	default:
 339:port.h        **** 		break;
 340:port.h        **** 	}
 341:port.h        **** }
 342:port.h        **** 
 343:port.h        **** /**
 344:port.h        ****  * \brief Set PORTC level
 345:port.h        ****  *
 346:port.h        ****  * Sets output level on the pins defined by the bit mask
 347:port.h        ****  *
 348:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 349:port.h        ****  *                  pin
 350:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 351:port.h        ****  *                  false = Pin levels set to "low" state
 352:port.h        ****  */
 353:port.h        **** static inline void PORTC_set_port_level(const uint8_t mask, const bool level)
 354:port.h        **** {
 355:port.h        **** 	if (level) {
 356:port.h        **** 		PORTC |= mask;
 357:port.h        **** 	} else {
 358:port.h        **** 		PORTC &= ~mask;
 359:port.h        **** 	}
 360:port.h        **** }
 361:port.h        **** 
 362:port.h        **** /**
 363:port.h        ****  * \brief Set PORTC level
 364:port.h        ****  *
 365:port.h        ****  * Sets output level on a pin
 366:port.h        ****  *
 367:port.h        ****  * \param[in] pin       The pin number for device
 368:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 369:port.h        ****  *                  false = Pin level set to "low" state
 370:port.h        ****  */
 371:port.h        **** static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
 372:port.h        **** {
 373:port.h        **** 	if (level) {
 374:port.h        **** 		PORTC |= 1 << pin;
 375:port.h        **** 	} else {
 376:port.h        **** 		PORTC &= ~(1 << pin);
  36               	 .loc 2 376 0
  37 0002 4598      	 cbi 0x8,5
  38               	.LVL2:
  39               	.LBE31:
  40               	.LBE30:
  41               	.LBE29:
  42               	.LBB32:
  43               	.LBB33:
  44               	.LBB34:
 276:port.h        **** 	}
  45               	 .loc 2 276 0
  46 0004 4598      	 cbi 0x8,5
  47               	.LVL3:
  48               	.LBE34:
  49               	.LBE33:
  50               	.LBE32:
  51               	.LBB35:
  52               	.LBB36:
  53               	.LBB37:
 331:port.h        **** 		break;
  54               	 .loc 2 331 0
  55 0006 3C9A      	 sbi 0x7,4
  56               	.LVL4:
  57               	.LBE37:
  58               	.LBE36:
  59               	.LBE35:
  60               	.LBB38:
  61               	.LBB39:
  62               	.LBB40:
  63               	 .loc 2 376 0
  64 0008 4498      	 cbi 0x8,4
  65               	.LVL5:
  66               	.LBE40:
  67               	.LBE39:
  68               	.LBE38:
  69               	.LBB41:
  70               	.LBB42:
  71               	.LBB43:
 276:port.h        **** 	}
  72               	 .loc 2 276 0
  73 000a 4498      	 cbi 0x8,4
  74               	.LVL6:
  75 000c 0895      	 ret
  76               	.LBE43:
  77               	.LBE42:
  78               	.LBE41:
  79               	 .cfi_endproc
  80               	.LFE105:
  82               	 .section .text.I2C_1_initialization,"ax",@progbits
  83               	.global I2C_1_initialization
  85               	I2C_1_initialization:
  86               	.LFB106:
  59:port_init.c   **** 
  60:port_init.c   **** 	PC5_set_dir(
  61:port_init.c   **** 	    // <y> Pin direction
  62:port_init.c   **** 	    // <id> pad_dir
  63:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
  64:port_init.c   **** 	    // <PORT_DIR_IN"> In
  65:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
  66:port_init.c   **** 	    PORT_DIR_OUT);
  67:port_init.c   **** 
  68:port_init.c   **** 	PC5_set_level(
  69:port_init.c   **** 	    // <y> Initial level
  70:port_init.c   **** 	    // <id> pad_initial_level
  71:port_init.c   **** 	    // <false"> Low
  72:port_init.c   **** 	    // <true"> High
  73:port_init.c   **** 	    false);
  74:port_init.c   **** 
  75:port_init.c   **** 	PC5_set_pull_mode(
  76:port_init.c   **** 	    // <y> Pull configuration
  77:port_init.c   **** 	    // <id> pad_pull_config
  78:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
  79:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
  80:port_init.c   **** 	    PORT_PULL_OFF);
  81:port_init.c   **** 
  82:port_init.c   **** 	PC4_set_dir(
  83:port_init.c   **** 	    // <y> Pin direction
  84:port_init.c   **** 	    // <id> pad_dir
  85:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
  86:port_init.c   **** 	    // <PORT_DIR_IN"> In
  87:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
  88:port_init.c   **** 	    PORT_DIR_OUT);
  89:port_init.c   **** 
  90:port_init.c   **** 	PC4_set_level(
  91:port_init.c   **** 	    // <y> Initial level
  92:port_init.c   **** 	    // <id> pad_initial_level
  93:port_init.c   **** 	    // <false"> Low
  94:port_init.c   **** 	    // <true"> High
  95:port_init.c   **** 	    false);
  96:port_init.c   **** 
  97:port_init.c   **** 	PC4_set_pull_mode(
  98:port_init.c   **** 	    // <y> Pull configuration
  99:port_init.c   **** 	    // <id> pad_pull_config
 100:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 101:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 102:port_init.c   **** 	    PORT_PULL_OFF);
 103:port_init.c   **** 
 104:port_init.c   **** }
 105:port_init.c   **** 
 106:port_init.c   **** /* configure pins and initialize registers */
 107:port_init.c   **** void I2C_1_initialization(void)
 108:port_init.c   **** {
  87               	 .loc 1 108 0
  88               	 .cfi_startproc
  89               	 
  90               	 
  91               	 
  92               	.L__stack_usage =0
  93               	.LVL7:
  94               	.LBB60:
  95               	.LBB61:
  96               	.LBB62:
 377:port.h        **** 	}
 378:port.h        **** }
 379:port.h        **** 
 380:port.h        **** /**
 381:port.h        ****  * \brief Toggle out level on pins
 382:port.h        ****  *
 383:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 384:port.h        ****  *
 385:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 386:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 387:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 388:port.h        ****  *                  pin
 389:port.h        ****  */
 390:port.h        **** static inline void PORTC_toggle_port_level(const uint8_t mask)
 391:port.h        **** {
 392:port.h        **** 	PINC = mask;
 393:port.h        **** }
 394:port.h        **** 
 395:port.h        **** /**
 396:port.h        ****  * \brief Toggle output level on pin
 397:port.h        ****  *
 398:port.h        ****  * Toggle the pin levels on pin
 399:port.h        ****  *
 400:port.h        ****  * \param[in] pin       The pin number for device
 401:port.h        ****  */
 402:port.h        **** static inline void PORTC_toggle_pin_level(const uint8_t pin)
 403:port.h        **** {
 404:port.h        **** 	PINC = 1 << pin;
 405:port.h        **** }
 406:port.h        **** 
 407:port.h        **** /**
 408:port.h        ****  * \brief Get input level on pins
 409:port.h        ****  *
 410:port.h        ****  * Read the input level on pins connected to a port
 411:port.h        ****  *
 412:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 413:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 414:port.h        ****  */
 415:port.h        **** static inline uint8_t PORTC_get_port_level(volatile uint8_t *port)
 416:port.h        **** {
 417:port.h        **** 	return PINC;
 418:port.h        **** }
 419:port.h        **** 
 420:port.h        **** /**
 421:port.h        ****  * \brief Get level on pin
 422:port.h        ****  *
 423:port.h        ****  * Reads the level on a pin connected to a port
 424:port.h        ****  *
 425:port.h        ****  * \param[in] pin       The pin number for device
 426:port.h        ****  */
 427:port.h        **** static inline bool PORTC_get_pin_level(const uint8_t pin)
 428:port.h        **** {
 429:port.h        **** 	return PINC & (1 << pin);
 430:port.h        **** }
 431:port.h        **** 
 432:port.h        **** /**
 433:port.h        ****  * \brief Write value to PORTC
 434:port.h        ****  *
 435:port.h        ****  * Write directly to the entire port register.
 436:port.h        ****  *
 437:port.h        ****  * \param[in] value   Value to write
 438:port.h        ****  */
 439:port.h        **** static inline void PORTC_write_port(const uint8_t value)
 440:port.h        **** {
 441:port.h        **** 	PORTC = value;
 442:port.h        **** }
 443:port.h        **** 
 444:port.h        **** /**
 445:port.h        ****  * \brief Set PORTD pin pull mode
 446:port.h        ****  *
 447:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 448:port.h        ****  * modes are defined by device used
 449:port.h        ****  *
 450:port.h        ****  * \param[in] pin       The pin number in PORTD
 451:port.h        ****  * \param[in] pull_mode Pin pull mode
 452:port.h        ****  */
 453:port.h        **** static inline void PORTD_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 454:port.h        **** {
 455:port.h        **** 
 456:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 457:port.h        **** 
 458:port.h        **** 		DDRD &= ~(1 << pin);
 459:port.h        **** 
 460:port.h        **** 		PORTD |= 1 << pin;
 461:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 462:port.h        **** 
 463:port.h        **** 		PORTD &= ~(1 << pin);
 464:port.h        **** 	}
 465:port.h        **** }
 466:port.h        **** 
 467:port.h        **** /**
 468:port.h        ****  * \brief Set PORTD data direction
 469:port.h        ****  *
 470:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 471:port.h        ****  * or disabled.
 472:port.h        ****  *
 473:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 474:port.h        ****  *                      corresponding pin
 475:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 476:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 477:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 478:port.h        ****  *                      (low power state)
 479:port.h        ****  */
 480:port.h        **** static inline void PORTD_set_port_dir(const uint8_t mask, const enum port_dir direction)
 481:port.h        **** {
 482:port.h        **** 	switch (direction) {
 483:port.h        **** 	case PORT_DIR_IN:
 484:port.h        **** 		DDRD &= ~mask;
 485:port.h        **** 		break;
 486:port.h        **** 	case PORT_DIR_OUT:
 487:port.h        **** 		DDRD |= mask;
 488:port.h        **** 		break;
 489:port.h        **** 	case PORT_DIR_OFF:
 490:port.h        **** 		DDRD &= ~mask;
 491:port.h        **** 
 492:port.h        **** 		PORTD |= mask;
 493:port.h        **** 		break;
 494:port.h        **** 	default:
 495:port.h        **** 		break;
 496:port.h        **** 	}
 497:port.h        **** }
 498:port.h        **** 
 499:port.h        **** /**
 500:port.h        ****  * \brief Set PORTD single pin data direction
 501:port.h        ****  *
 502:port.h        ****  * Select if the pin data direction is input, output or disabled.
 503:port.h        ****  * If disabled state is not possible, this function throws an assert.
 504:port.h        ****  *
 505:port.h        ****  * \param[in] pin       The pin number within PORTD (0..7)
 506:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 507:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 508:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 509:port.h        ****  *                      (low power state)
 510:port.h        ****  */
 511:port.h        **** static inline void PORTD_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 512:port.h        **** {
 513:port.h        **** 	switch (direction) {
 514:port.h        **** 	case PORT_DIR_IN:
 515:port.h        **** 		DDRD &= ~(1 << pin);
 516:port.h        **** 		break;
 517:port.h        **** 	case PORT_DIR_OUT:
 518:port.h        **** 		DDRD |= 1 << pin;
 519:port.h        **** 		break;
 520:port.h        **** 	case PORT_DIR_OFF:
 521:port.h        **** 		DDRD |= ~(1 << pin);
 522:port.h        **** 
 523:port.h        **** 		PORTD |= 1 << pin;
 524:port.h        **** 		break;
 525:port.h        **** 	default:
 526:port.h        **** 		break;
 527:port.h        **** 	}
 528:port.h        **** }
 529:port.h        **** 
 530:port.h        **** /**
 531:port.h        ****  * \brief Set PORTD level
 532:port.h        ****  *
 533:port.h        ****  * Sets output level on the pins defined by the bit mask
 534:port.h        ****  *
 535:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 536:port.h        ****  *                  pin
 537:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 538:port.h        ****  *                  false = Pin levels set to "low" state
 539:port.h        ****  */
 540:port.h        **** static inline void PORTD_set_port_level(const uint8_t mask, const bool level)
 541:port.h        **** {
 542:port.h        **** 	if (level) {
 543:port.h        **** 		PORTD |= mask;
 544:port.h        **** 	} else {
 545:port.h        **** 		PORTD &= ~mask;
 546:port.h        **** 	}
 547:port.h        **** }
 548:port.h        **** 
 549:port.h        **** /**
 550:port.h        ****  * \brief Set PORTD level
 551:port.h        ****  *
 552:port.h        ****  * Sets output level on a pin
 553:port.h        ****  *
 554:port.h        ****  * \param[in] pin       The pin number for device
 555:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 556:port.h        ****  *                  false = Pin level set to "low" state
 557:port.h        ****  */
 558:port.h        **** static inline void PORTD_set_pin_level(const uint8_t pin, const bool level)
 559:port.h        **** {
 560:port.h        **** 	if (level) {
 561:port.h        **** 		PORTD |= 1 << pin;
 562:port.h        **** 	} else {
 563:port.h        **** 		PORTD &= ~(1 << pin);
 564:port.h        **** 	}
 565:port.h        **** }
 566:port.h        **** 
 567:port.h        **** /**
 568:port.h        ****  * \brief Toggle out level on pins
 569:port.h        ****  *
 570:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 571:port.h        ****  *
 572:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 573:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 574:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 575:port.h        ****  *                  pin
 576:port.h        ****  */
 577:port.h        **** static inline void PORTD_toggle_port_level(const uint8_t mask)
 578:port.h        **** {
 579:port.h        **** 	PIND = mask;
 580:port.h        **** }
 581:port.h        **** 
 582:port.h        **** /**
 583:port.h        ****  * \brief Toggle output level on pin
 584:port.h        ****  *
 585:port.h        ****  * Toggle the pin levels on pin
 586:port.h        ****  *
 587:port.h        ****  * \param[in] pin       The pin number for device
 588:port.h        ****  */
 589:port.h        **** static inline void PORTD_toggle_pin_level(const uint8_t pin)
 590:port.h        **** {
 591:port.h        **** 	PIND = 1 << pin;
 592:port.h        **** }
 593:port.h        **** 
 594:port.h        **** /**
 595:port.h        ****  * \brief Get input level on pins
 596:port.h        ****  *
 597:port.h        ****  * Read the input level on pins connected to a port
 598:port.h        ****  *
 599:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 600:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 601:port.h        ****  */
 602:port.h        **** static inline uint8_t PORTD_get_port_level(volatile uint8_t *port)
 603:port.h        **** {
 604:port.h        **** 	return PIND;
 605:port.h        **** }
 606:port.h        **** 
 607:port.h        **** /**
 608:port.h        ****  * \brief Get level on pin
 609:port.h        ****  *
 610:port.h        ****  * Reads the level on a pin connected to a port
 611:port.h        ****  *
 612:port.h        ****  * \param[in] pin       The pin number for device
 613:port.h        ****  */
 614:port.h        **** static inline bool PORTD_get_pin_level(const uint8_t pin)
 615:port.h        **** {
 616:port.h        **** 	return PIND & (1 << pin);
 617:port.h        **** }
 618:port.h        **** 
 619:port.h        **** /**
 620:port.h        ****  * \brief Write value to PORTD
 621:port.h        ****  *
 622:port.h        ****  * Write directly to the entire port register.
 623:port.h        ****  *
 624:port.h        ****  * \param[in] value   Value to write
 625:port.h        ****  */
 626:port.h        **** static inline void PORTD_write_port(const uint8_t value)
 627:port.h        **** {
 628:port.h        **** 	PORTD = value;
 629:port.h        **** }
 630:port.h        **** 
 631:port.h        **** /**
 632:port.h        ****  * \brief Set PORTE pin pull mode
 633:port.h        ****  *
 634:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 635:port.h        ****  * modes are defined by device used
 636:port.h        ****  *
 637:port.h        ****  * \param[in] pin       The pin number in PORTE
 638:port.h        ****  * \param[in] pull_mode Pin pull mode
 639:port.h        ****  */
 640:port.h        **** static inline void PORTE_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 641:port.h        **** {
 642:port.h        **** 
 643:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 644:port.h        **** 
 645:port.h        **** 		DDRE &= ~(1 << pin);
 646:port.h        **** 
 647:port.h        **** 		PORTE |= 1 << pin;
 648:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 649:port.h        **** 
 650:port.h        **** 		PORTE &= ~(1 << pin);
 651:port.h        **** 	}
 652:port.h        **** }
 653:port.h        **** 
 654:port.h        **** /**
 655:port.h        ****  * \brief Set PORTE data direction
 656:port.h        ****  *
 657:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 658:port.h        ****  * or disabled.
 659:port.h        ****  *
 660:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 661:port.h        ****  *                      corresponding pin
 662:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 663:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 664:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 665:port.h        ****  *                      (low power state)
 666:port.h        ****  */
 667:port.h        **** static inline void PORTE_set_port_dir(const uint8_t mask, const enum port_dir direction)
 668:port.h        **** {
 669:port.h        **** 	switch (direction) {
 670:port.h        **** 	case PORT_DIR_IN:
 671:port.h        **** 		DDRE &= ~mask;
 672:port.h        **** 		break;
 673:port.h        **** 	case PORT_DIR_OUT:
 674:port.h        **** 		DDRE |= mask;
 675:port.h        **** 		break;
 676:port.h        **** 	case PORT_DIR_OFF:
 677:port.h        **** 		DDRE &= ~mask;
 678:port.h        **** 
 679:port.h        **** 		PORTE |= mask;
 680:port.h        **** 		break;
 681:port.h        **** 	default:
 682:port.h        **** 		break;
 683:port.h        **** 	}
 684:port.h        **** }
 685:port.h        **** 
 686:port.h        **** /**
 687:port.h        ****  * \brief Set PORTE single pin data direction
 688:port.h        ****  *
 689:port.h        ****  * Select if the pin data direction is input, output or disabled.
 690:port.h        ****  * If disabled state is not possible, this function throws an assert.
 691:port.h        ****  *
 692:port.h        ****  * \param[in] pin       The pin number within PORTE (0..7)
 693:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 694:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 695:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 696:port.h        ****  *                      (low power state)
 697:port.h        ****  */
 698:port.h        **** static inline void PORTE_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 699:port.h        **** {
 700:port.h        **** 	switch (direction) {
 701:port.h        **** 	case PORT_DIR_IN:
 702:port.h        **** 		DDRE &= ~(1 << pin);
  97               	 .loc 2 702 0
  98 0000 6998      	 cbi 0xd,1
  99               	.LVL8:
 100               	.LBE62:
 101               	.LBE61:
 102               	.LBE60:
 103               	.LBB63:
 104               	.LBB64:
 105               	.LBB65:
 650:port.h        **** 	}
 106               	 .loc 2 650 0
 107 0002 7198      	 cbi 0xe,1
 108               	.LVL9:
 109               	.LBE65:
 110               	.LBE64:
 111               	.LBE63:
 112               	.LBB66:
 113               	.LBB67:
 114               	.LBB68:
 115               	 .loc 2 702 0
 116 0004 6898      	 cbi 0xd,0
 117               	.LVL10:
 118               	.LBE68:
 119               	.LBE67:
 120               	.LBE66:
 121               	.LBB69:
 122               	.LBB70:
 123               	.LBB71:
 650:port.h        **** 	}
 124               	 .loc 2 650 0
 125 0006 7098      	 cbi 0xe,0
 126               	.LVL11:
 127 0008 0895      	 ret
 128               	.LBE71:
 129               	.LBE70:
 130               	.LBE69:
 131               	 .cfi_endproc
 132               	.LFE106:
 134               	 .section .text.port_init,"ax",@progbits
 135               	.global port_init
 137               	port_init:
 138               	.LFB107:
 109:port_init.c   **** 
 110:port_init.c   **** 	PE1_set_dir(
 111:port_init.c   **** 	    // <y> Pin direction
 112:port_init.c   **** 	    // <id> pad_dir
 113:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
 114:port_init.c   **** 	    // <PORT_DIR_IN"> In
 115:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
 116:port_init.c   **** 	    PORT_DIR_IN);
 117:port_init.c   **** 
 118:port_init.c   **** 	PE1_set_pull_mode(
 119:port_init.c   **** 	    // <y> Pull configuration
 120:port_init.c   **** 	    // <id> pad_pull_config
 121:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 122:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 123:port_init.c   **** 	    PORT_PULL_OFF);
 124:port_init.c   **** 
 125:port_init.c   **** 	PE0_set_dir(
 126:port_init.c   **** 	    // <y> Pin direction
 127:port_init.c   **** 	    // <id> pad_dir
 128:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
 129:port_init.c   **** 	    // <PORT_DIR_IN"> In
 130:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
 131:port_init.c   **** 	    PORT_DIR_IN);
 132:port_init.c   **** 
 133:port_init.c   **** 	PE0_set_pull_mode(
 134:port_init.c   **** 	    // <y> Pull configuration
 135:port_init.c   **** 	    // <id> pad_pull_config
 136:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 137:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 138:port_init.c   **** 	    PORT_PULL_OFF);
 139:port_init.c   **** 
 140:port_init.c   **** }
 141:port_init.c   **** 
 142:port_init.c   **** void port_init()
 143:port_init.c   **** {
 139               	 .loc 1 143 0
 140               	 .cfi_startproc
 141               	 
 142               	 
 143               	 
 144               	.L__stack_usage =0
 144:port_init.c   **** 	I2C_0_initialization();
 145               	 .loc 1 144 0
 146 0000 0E94 0000 	 call I2C_0_initialization
 147               	.LVL12:
 148               	.LBB112:
 149               	.LBB113:
 150               	.LBB114:
 141:port.h        **** 		break;
 151               	 .loc 2 141 0
 152 0004 2698      	 cbi 0x4,6
 153               	.LVL13:
 154               	.LBE114:
 155               	.LBE113:
 156               	.LBE112:
 157               	.LBB115:
 158               	.LBB116:
 159               	.LBB117:
  89:port.h        **** 	}
 160               	 .loc 2 89 0
 161 0006 2E98      	 cbi 0x5,6
 162               	.LVL14:
 163               	.LBE117:
 164               	.LBE116:
 165               	.LBE115:
 166               	.LBB118:
 167               	.LBB119:
 168               	.LBB120:
 328:port.h        **** 		break;
 169               	 .loc 2 328 0
 170 0008 3998      	 cbi 0x7,1
 171               	.LVL15:
 172               	.LBE120:
 173               	.LBE119:
 174               	.LBE118:
 175               	.LBB121:
 176               	.LBB122:
 177               	.LBB123:
 276:port.h        **** 	}
 178               	 .loc 2 276 0
 179 000a 4198      	 cbi 0x8,1
 180               	.LVL16:
 181               	.LBE123:
 182               	.LBE122:
 183               	.LBE121:
 184               	.LBB124:
 185               	.LBB125:
 186               	.LBB126:
 515:port.h        **** 		break;
 187               	 .loc 2 515 0
 188 000c 5398      	 cbi 0xa,3
 189               	.LVL17:
 190               	.LBE126:
 191               	.LBE125:
 192               	.LBE124:
 193               	.LBB127:
 194               	.LBB128:
 195               	.LBB129:
 463:port.h        **** 	}
 196               	 .loc 2 463 0
 197 000e 5B98      	 cbi 0xb,3
 198               	.LVL18:
 199               	.LBE129:
 200               	.LBE128:
 201               	.LBE127:
 202               	.LBB130:
 203               	.LBB131:
 204               	.LBB132:
 515:port.h        **** 		break;
 205               	 .loc 2 515 0
 206 0010 5598      	 cbi 0xa,5
 207               	.LVL19:
 208               	.LBE132:
 209               	.LBE131:
 210               	.LBE130:
 211               	.LBB133:
 212               	.LBB134:
 213               	.LBB135:
 463:port.h        **** 	}
 214               	 .loc 2 463 0
 215 0012 5D98      	 cbi 0xb,5
 216               	.LVL20:
 217               	.LBE135:
 218               	.LBE134:
 219               	.LBE133:
 220               	.LBB136:
 221               	.LBB137:
 222               	.LBB138:
 703:port.h        **** 		break;
 704:port.h        **** 	case PORT_DIR_OUT:
 705:port.h        **** 		DDRE |= 1 << pin;
 223               	 .loc 2 705 0
 224 0014 6B9A      	 sbi 0xd,3
 225               	.LVL21:
 226               	.LBE138:
 227               	.LBE137:
 228               	.LBE136:
 229               	.LBB139:
 230               	.LBB140:
 231               	.LBB141:
 706:port.h        **** 		break;
 707:port.h        **** 	case PORT_DIR_OFF:
 708:port.h        **** 		DDRE |= ~(1 << pin);
 709:port.h        **** 
 710:port.h        **** 		PORTE |= 1 << pin;
 711:port.h        **** 		break;
 712:port.h        **** 	default:
 713:port.h        **** 		break;
 714:port.h        **** 	}
 715:port.h        **** }
 716:port.h        **** 
 717:port.h        **** /**
 718:port.h        ****  * \brief Set PORTE level
 719:port.h        ****  *
 720:port.h        ****  * Sets output level on the pins defined by the bit mask
 721:port.h        ****  *
 722:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 723:port.h        ****  *                  pin
 724:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 725:port.h        ****  *                  false = Pin levels set to "low" state
 726:port.h        ****  */
 727:port.h        **** static inline void PORTE_set_port_level(const uint8_t mask, const bool level)
 728:port.h        **** {
 729:port.h        **** 	if (level) {
 730:port.h        **** 		PORTE |= mask;
 731:port.h        **** 	} else {
 732:port.h        **** 		PORTE &= ~mask;
 733:port.h        **** 	}
 734:port.h        **** }
 735:port.h        **** 
 736:port.h        **** /**
 737:port.h        ****  * \brief Set PORTE level
 738:port.h        ****  *
 739:port.h        ****  * Sets output level on a pin
 740:port.h        ****  *
 741:port.h        ****  * \param[in] pin       The pin number for device
 742:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 743:port.h        ****  *                  false = Pin level set to "low" state
 744:port.h        ****  */
 745:port.h        **** static inline void PORTE_set_pin_level(const uint8_t pin, const bool level)
 746:port.h        **** {
 747:port.h        **** 	if (level) {
 748:port.h        **** 		PORTE |= 1 << pin;
 232               	 .loc 2 748 0
 233 0016 739A      	 sbi 0xe,3
 234               	.LVL22:
 235 0018 0895      	 ret
 236               	.LBE141:
 237               	.LBE140:
 238               	.LBE139:
 239               	 .cfi_endproc
 240               	.LFE107:
 242               	 .text
 243               	.Letext0:
 244               	 .file 3 "atmel_start_pins.h"
 245               	 .file 4 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 port_init.c
    {standard input}:2      *ABS*:0000003e __SP_H__
    {standard input}:3      *ABS*:0000003d __SP_L__
    {standard input}:4      *ABS*:0000003f __SREG__
    {standard input}:5      *ABS*:00000000 __tmp_reg__
    {standard input}:6      *ABS*:00000001 __zero_reg__
    {standard input}:13     .text.I2C_0_initialization:00000000 I2C_0_initialization
    {standard input}:85     .text.I2C_1_initialization:00000000 I2C_1_initialization
    {standard input}:137    .text.port_init:00000000 port_init

NO UNDEFINED SYMBOLS
